<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>pimged.datahandling.dataloading API documentation</title>
<meta name="description" content="Dataload structure for the PImGED framework." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
<style>.homelink{display:block;font-size:2em;font-weight:bold;color:#555;padding-bottom:.5em;border-bottom:1px solid silver}.homelink:hover{color:inherit}.homelink img{max-width:100%;max-height:10em;margin:auto;margin-bottom:.3em;margin-top:.3em}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pimged.datahandling.dataloading</code></h1>
</header>
<section id="section-intro">
<p>Dataload structure for the PImGED framework.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Dataload structure for the PImGED framework.&#34;&#34;&#34;
from cv2 import imread, IMREAD_UNCHANGED
from os import path as ph, listdir
from glob import glob
from joblib import Parallel, delayed, cpu_count
from tqdm import tqdm
from re import split, findall, sub
import numpy as np
import fnmatch

from ..utils.utils import range_load_check, find_dir_contains, get_folder_paths
from ..utils.chixread import checkingchixfileset
from ..utils.chixread import ImageData, CameraData
from ..utils.naturalkeysort import naturalkeysort
from .datacontainers import Imagearrays, Pressurearrays, Filesinfo


# Exclude imread from cv2 package from the automated generated documentation
__pdoc__ = {&#39;imread&#39;: False}


class Dataload:
    &#34;&#34;&#34;Class for loading data into a dataset struct for the PImGED framework.&#34;&#34;&#34;

    def __init__(self,
                 imagearrays: Imagearrays,
                 pressurearrays: Pressurearrays,
                 fileinfo: Filesinfo,
                 mainpath: str,
                 imagesearchfolders: list,
                 zeroparticlesfolder: str,
                 pressuresearchfolders: list = None,
                 imagefoldername: str = None,
                 pressurefoldername: str = &#34;&#34;,
                 fullparticlesfolder: str = &#34;&#34;,
                 errignor: bool = True,
                 checkmeta: bool = True,
                 loadmeta: bool = True):
        &#34;&#34;&#34;Class to handle all functions and data for dataloading.

        Parameters
        ----------
        imagearrays : pimged.Imarrays :
            REQUIERED
            all imagearray data input as the Imagearrays object

        pressurearrays : pimged.Pressurearrays :
            REQUIERED
            all pressure array data

        fileinfo : pimged.Fileinfo :
            REQUIERED
            file metadata for loaded files as the Filesinfo object

        mainpath : str :
            REQUIERED
            The main directory path where the image folder and pressure folders are positioned

        imagefoldername : str :
            REQUIRED
            foldername inside the main path containing the imagefolders

        imagesearchfolders : list :
            REQUIERED
            list of the folders present in the image folder that contain the images for the dataset

        zeroparticlesfolder : str :
            REQUIRED
            name of the folder with the initial images without particles

        pressurefoldername : str :
            OPTIONAL
            (Default value = &#39;&#39;)
            foldername inside the main path for the pressure datasets

        pressuresearchfolders : list :
            OPTIONAL
            list of folders present in the main path that contain the pressure data for the image
            series. (can be left out)

        fullparticlesfolder : str :
            OPTIONAL
            (Default value = &#39;&#39;)
            If given the code use this folder for all calibrations of densities. It is
            adviced not to use this function, may be depricated later

        errignor : bool :
            (Default value = True)
            false - raise error if not all inifiles have the same image and camera data,
            true - show warning

        checkmeta : bool :
            (Default value = True)
            true - check if dataseries metadata should be compared for series integrety
            flase - no check

        loadmeta : bool :
            (Default value = True)
            If the metadata should be loaded
        &#34;&#34;&#34;
        self.fileinfo = fileinfo
        self.fileinfo.mainpath = mainpath
        self.fileinfo.imagesearchfolders = imagesearchfolders
        self.fileinfo.imagefoldername = imagefoldername
        self.fileinfo.pressuresearchfolders = pressurefoldername
        self.fileinfo.pressuresearchfolders = pressuresearchfolders
        self.fileinfo.zeroparticlesfolder = zeroparticlesfolder
        self.fileinfo.fullparticlesfolder = fullparticlesfolder
        self.fileinfo.errignor = errignor

        self._imagearrays = imagearrays
        self._pressurearrays = pressurearrays
        self._imagesfullpath = ph.join(mainpath, imagefoldername)
        self._pressuresfullpath = ph.join(mainpath, pressurefoldername)

        # IF THE CODE SHOULD BE MODIFIED FOR DATA WITHOUT CHIX FILES, MAKE A CHECK THAT IGNORES
        # THE LINES BELOW
        if checkmeta:
            # Checking if the datahandling is coherent in accusition setup
            checkingchixfileset(self._imagesfullpath, imagesearchfolders, errignor)

        if loadmeta:
            # If the files are approved, the camera and image data from the first files is read and
            # a list of each datahandling start recording times
            print(&#39;Loading chosen files meta data&#39;)
            self.fileinfo.imagedata = ImageData(self._imagesfullpath, imagesearchfolders)
            self.fileinfo.cameradata = CameraData(self._imagesfullpath, imagesearchfolders)
            print(&#39;Done\n\n&#39;)

    def loadimages(self,
                   loadzeroimages: bool = False,
                   setfolderstoload: list = &#39;all&#39;,
                   setimagestoload: list = &#39;all&#39;,
                   verb: bool = False,
                   loadmethodfolder: str = &#39;range&#39;,
                   loadmethodimage: str = &#39;range&#39;,
                   parset: bool = True,
                   natkeysort: bool = True):
        &#34;&#34;&#34;Load data from set of images exported from PFV with a cihx inifile.

        The loaded data is populated in the raw image datacontainer of the dataset and contain
        data with 4 dimensions.
        ndarray([H, W, Time, Statio. time])

        #### H:
        is the height of the image in pixel

        #### W:
        is the width in pixel

        #### Time:
        is progress in time for each repetition

        #### Statio. time:
        is the repetition of datasets stationary in time


        It is demanded that all datasets given have the same number of images in the folder

        Parameters
        ----------
        loadzeroimages : bool :
             (Default value = False)
            if the zero images of the datasetshould be loaded in

        setfolderstoload : list :
             (Default value = &#39;all&#39;)
            input has to be a list with start and end index of folders to load
            in path.

        setimagestoload : list :
             (Default value = &#39;all&#39;)
            input has to be a list with start and end index of images in sets to
            load in path

        verb : bool :
             (Default value = False)
            verbosity of code. False is no info, True is folder progress

        loadmethodfolder : str :
             (Default value = &#39;range&#39;)
            {&#39;range&#39;, &#39;spec&#39;}
            how to intrepreate the set inputs.
            &#39;range&#39; take first and last element of lists to create a range to loop,
            &#39;spec&#39; setting use the given list as a specific list of positions to load
            images and folders

        loadmethodimage : str :
             (Default value = &#39;range&#39;)
            {&#39;range&#39;, &#39;spec&#39;}
            how to intrepreate the set inputs.
            &#39;range&#39; take first and last element of lists to create a range to loop,
            &#39;spec&#39; setting use the given list as a specific list of positions to load images and
            folders

        parset : bool :
             (Default value = True)
            if the loading process should be threaded, True or False

        natkeysort : bool :
             (Default value = True)
            if the seachfolder input list should be sorted according to the
            natural key method

        Raises
        ------
        AttributeError : :
            If image metadata is not loaded
        &#34;&#34;&#34;
        if not hasattr(self.fileinfo.imagedata, &#39;totalframes&#39;):
            raise AttributeError(&#34;Imagedata are not loaded during the initilization of the &#34;
                                 &#34;framework. Specify the maximum number of images present in &#34;
                                 &#34;the datasets by loading the metadata files at initilization.&#34;)

        if loadzeroimages:
            self._loadimageszeros(verb=True, parsetload=True)
        else:

            self.fileinfo.loadedimagerange = setimagestoload
            self.fileinfo.loadeddatasets = setfolderstoload

            maxnumimagefiles = list(range(0, self.fileinfo.imagedata.totalframes, 1))

            # Creating the new list that can be sorted without altering the orignal info
            sortedfolderlist = self.fileinfo.imagesearchfolders.copy()
            if natkeysort:
                naturalkeysort(sortedfolderlist)

            folderstoload = range_load_check(sortedfolderlist,
                                             setfolderstoload,
                                             &#39;all&#39;,
                                             list,
                                             loadmethodfolder)
            imagestoload = range_load_check(maxnumimagefiles,
                                            setimagestoload,
                                            &#39;all&#39;,
                                            list,
                                            loadmethodimage)

            nblocksload = len(folderstoload)
            nframesperset = len(imagestoload)

            print(&#39;Starting to load image data&#39;)

            self._imagearrays.raw.data = self._loadpictures(nblocks=nblocksload,
                                                            nframesperset=nframesperset,
                                                            verb=verb,
                                                            parset=parset,
                                                            imagestoload=imagestoload,
                                                            folderstoload=folderstoload)

            # updating the raw image info
            self._imagearrays.raw.arrayinfo.loadeddatasets = [setfolderstoload[0],
                                                              setfolderstoload[0]+nblocksload-1]
            if len(setimagestoload) == 1:
                self._imagearrays.raw.arrayinfo.loadedimagerange = [setimagestoload[0],
                                                                    setimagestoload[0]]
            else:
                self._imagearrays.raw.arrayinfo.loadedimagerange = [setimagestoload[0],
                                                                    setimagestoload[1]]

    def _loadimageszeros(self, verb: bool = True, parsetload: bool = True):
        &#34;&#34;&#34;Shortcut function for loading zero images.

        Parameters
        ----------
        verb : bool :
             (Default value = True)
            verbosity of code. False is no info, True is folder progress

        parsetload : bool :
             (Default value = True)
            if the loading process should be threaded, True or False

        Raises
        ------
        NotADirectoryError : :
            The provided zero particle folder do not exist
        &#34;&#34;&#34;
        # creating the imagefilespath
        imfiledir = ph.join(self.fileinfo.mainpath, self.fileinfo.imagefoldername)

        # Checking if the sero particle folder given exist in any of the dataset directory
        # folder names
        pathforzeroparticleimages = get_folder_paths(imfiledir,
                                                     self.fileinfo.zeroparticlesfolder)[0]

        if not ph.exists(pathforzeroparticleimages):
            raise NotADirectoryError(&#34;The given zero particle folder do not exist&#34;)

        # Setting blocks and images in the zero particles images folder
        nblockperload = 1
        nframespersetzero = len(find_dir_contains(pathforzeroparticleimages,
                                                  self.fileinfo.imagedata.fileformat))

        # Loading zero particle images
        print(&#39;Loading Zero particle images&#39;)
        # noinspection PyProtectedMember
        self._imagearrays.zero.data = \
            self._loadpictures(nblockperload,
                               nframespersetzero,
                               verb=verb,
                               zerosetload=True,
                               parset=parsetload)

        self._imagearrays.zero.arrayinfo.loadeddatasets = [1, 1]
        self._imagearrays.zero.arrayinfo.loadedimagerange = [1, nframespersetzero]

        print(&#39;Done loading images\n\n&#39;)

    def loadpressuresOLD(self,
                         setfilestoload: list = &#39;all&#39;,
                         natkeysort: bool = True,
                         loadmethodfolder: str = &#39;range&#39;,
                         ndatalines: int = 5,
                         npresslines: int = 3):
        &#34;&#34;&#34;Load data into the pressure, time and vale signal into the pressure arrays.

        for the old pressure file setup design

        Parameters
        ----------
        setfilestoload : list :
             (Default value = &#39;all&#39;)
             list of files to load

        natkeysort : bool :
             (Default value = True)
             if the list should be sorted with natural order sorting

        loadmethodfolder : str :
             (Default value = &#39;range&#39;)
            {&#39;range&#39;, &#39;spec&#39;}
            how to intrepreate the set inputs.
            &#39;range&#39; take first and last element of lists to create a range to loop,
            &#39;spec&#39; setting use the given list as a specific list of positions to load
            images and folders

        ndatalines : int :
             (Default value = 5)
             numbder of columns with data

        npresslines : int :
             (Default value = 3)
            numboer of pressure sensors in file
        &#34;&#34;&#34;
        # File dependent info
        roominfoidx = 0
        caliblineidx = slice(3, 5)
        datarowidxstart = 7

        # Creating the new list that can be sorted without altering the orignal info
        sortedfolderlist = self.fileinfo.pressuresearchfolders.copy()
        if natkeysort:
            naturalkeysort(sortedfolderlist)

        # Cehcking for the files wanted
        pressfiles = range_load_check(sortedfolderlist, setfilestoload, &#39;all&#39;, list,
                                      loadmethodfolder)
        nblocksload = len(pressfiles)

        # Update the metadata
        self._pressurearrays.loadedpressurerange = [setfilestoload[0],
                                                    setfilestoload[0] + nblocksload - 1]

        print(&#39;Starting to load pressure data&#39;)

        # Building path to first file for reading basic info
        filepath = ph.join(self._pressuresfullpath, pressfiles[0])

        with open(filepath, &#39;r&#39;) as f:
            readlines = f.readlines()
            ndatapoints = len(readlines[datarowidxstart:])

        # noinspection PyProtectedMember
        precision = self._pressurearrays._precision_calc
        nsets = len(pressfiles)

        calibrations = np.zeros((4, 2), dtype=precision)
        self._pressurearrays.time = np.zeros((ndatapoints, nsets), dtype=precision)
        self._pressurearrays.valve = np.zeros((ndatapoints, nsets), dtype=precision)
        self._pressurearrays.temperature = np.zeros(nsets, dtype=precision)
        self._pressurearrays.pressure_atm = np.zeros(nsets, dtype=precision)
        for i in range(1, npresslines+1):
            exec(&#39;self._pressurearrays.pressure&#39; + str(i) +
                 &#39;.voltage= np.zeros((ndatapoints, nsets), dtype=precision)&#39;)
            exec(&#39;self._pressurearrays.pressure&#39; + str(i) +
                 &#39;.calibration = np.zeros((2, nsets), dtype=precision)&#39;)

        for i, file in enumerate(pressfiles):
            filepath = ph.join(self._pressuresfullpath, file)
            with open(filepath, &#39;r&#39;) as f:
                readlines = f.readlines()

                # reads the pressure and temperature in
                readnums = findall(r&#39;[+\-]?(?:0|[1-9]\d*)(?:\.\d*)?(?:[eE][+\-]?\d+)&#39;,
                                   readlines[roominfoidx].replace(&#39;,&#39;, &#39;.&#39;))
                self._pressurearrays.pressure_atm[i] = readnums[0]
                self._pressurearrays.temperature[i] = readnums[1]

                # Get the calibration data
                for j, line in enumerate(readlines[caliblineidx]):
                    listofsplits = split(r&#39;\t+&#39;, line.replace(&#39;,&#39;, &#39;.&#39;).rstrip(&#39;\n&#39;))
                    calibrations[:, j] = np.array(listofsplits)

                for j in range(1, npresslines+1):
                    exec(&#39;self._pressurearrays.pressure&#39; + str(j) +
                         &#39;.calibration[:, i] = calibrations[&#39; + str(j-1) + &#39;, :]&#39;)

                # Subtract data series from file
                flatlines = sub(&#39;,&#39;, &#39;.&#39;, &#34;&#34;.join(readlines[datarowidxstart:]))
                data = np.array(findall(r&#39;[+\-]?(?:0|[1-9]\d*)(?:\.\d*)?(?:[eE][+\-]?\d+)&#39;,
                                        flatlines))
                data = data.reshape(-1, ndatalines)

                # Store data
                self._pressurearrays.time[:, i] = data[:, 0]
                self._pressurearrays.valve[:, i] = data[:, npresslines+1]
                for j in range(1, npresslines+1):
                    exec(&#39;self._pressurearrays.pressure&#39; + str(j) +
                         &#39;.voltage[:, i] = data[: ,&#39; + str(j) + &#39;]&#39;)

        print(&#39;Done loading pressure data\n\n&#39;)

    def loadpressures(self,
                      setfilestoload: list = &#39;all&#39;,
                      natkeysort: bool = True,
                      loadmethodfolder: str = &#39;range&#39;,
                      ndatalines: int = 6,
                      npresslines: int = 3):
        &#34;&#34;&#34;Load data into the pressure, time and vale signal into the pressure arrays.

        Parameters
        ----------
        setfilestoload : list :
             (Default value = &#39;all&#39;)
             list of files to load

        natkeysort : bool :
             (Default value = True)
             if the list should be sorted with natural order sorting

        loadmethodfolder : str :
             (Default value = &#39;range&#39;)
            {&#39;range&#39;, &#39;spec&#39;}
            how to intrepreate the set inputs.
            &#39;range&#39; take first and last element of lists to create a range to loop,
            &#39;spec&#39; setting use the given list as a specific list of positions to load
            images and folders

        ndatalines : int :
             (Default value = 5)
             numbder of columns with data

        npresslines : int :
             (Default value = 3)
            numboer of pressure sensors in file
        &#34;&#34;&#34;
        # File dependent info
        roominfoidx = 0
        caliblineidx = slice(3, 5)
        datarowidxstart = 7

        # Creating the new list that can be sorted without altering the orignal info
        sortedfolderlist = self.fileinfo.pressuresearchfolders.copy()
        if natkeysort:
            naturalkeysort(sortedfolderlist)

        # Cehcking for the files wanted
        pressfiles = range_load_check(sortedfolderlist, setfilestoload, &#39;all&#39;, list,
                                      loadmethodfolder)
        nblocksload = len(pressfiles)

        # Update the metadata
        self._pressurearrays.loadedpressurerange = [setfilestoload[0],
                                                    setfilestoload[0] + nblocksload - 1]

        print(&#39;Starting to load pressure data&#39;)

        # Building path to first file for reading basic info
        filepath = ph.join(self._pressuresfullpath, pressfiles[0])

        with open(filepath, &#39;r&#39;) as f:
            readlines = f.readlines()
            ndatapoints = len(readlines[datarowidxstart:])

        # noinspection PyProtectedMember
        precision = self._pressurearrays._precision_calc
        nsets = len(pressfiles)

        calibrations = np.zeros((4, 2), dtype=precision)
        self._pressurearrays.time = np.zeros((ndatapoints, nsets), dtype=precision)
        self._pressurearrays.valve = np.zeros((ndatapoints, nsets), dtype=precision)
        self._pressurearrays.camera = np.zeros((ndatapoints, nsets), dtype=precision)
        self._pressurearrays.temperature = np.zeros(nsets, dtype=precision)
        self._pressurearrays.pressure_atm = np.zeros(nsets, dtype=precision)
        for i in range(1, npresslines+1):
            exec(&#39;self._pressurearrays.pressure&#39; + str(i) +
                 &#39;.voltage= np.zeros((ndatapoints, nsets), dtype=precision)&#39;)
            exec(&#39;self._pressurearrays.pressure&#39; + str(i) +
                 &#39;.calibration = np.zeros((2, nsets), dtype=precision)&#39;)

        for i, file in enumerate(pressfiles):
            filepath = ph.join(self._pressuresfullpath, file)
            with open(filepath, &#39;r&#39;) as f:
                readlines = f.readlines()

                # reads the pressure and temperature in
                readnums = findall(r&#39;[+\-]?(?:0|[1-9]\d*)(?:\.\d*)?(?:[eE][+\-]?\d+)&#39;,
                                   readlines[roominfoidx].replace(&#39;,&#39;, &#39;.&#39;))
                self._pressurearrays.pressure_atm[i] = readnums[0]
                self._pressurearrays.temperature[i] = readnums[1]

                # Get the calibration data
                for j, line in enumerate(readlines[caliblineidx]):
                    listofsplits = split(r&#39;\t+&#39;, line.replace(&#39;,&#39;, &#39;.&#39;).rstrip(&#39;\n&#39;))
                    calibrations[:, j] = np.array(listofsplits)

                for j in range(1, npresslines+1):
                    exec(&#39;self._pressurearrays.pressure&#39; + str(j) +
                         &#39;.calibration[:, i] = calibrations[&#39; + str(j-1) + &#39;, :]&#39;)

                # Subtract data series from file
                flatlines = sub(&#39;,&#39;, &#39;.&#39;, &#34;&#34;.join(readlines[datarowidxstart:]))
                data = np.array(findall(r&#39;[+\-]?(?:0|[1-9]\d*)(?:\.\d*)?(?:[eE][+\-]?\d+)&#39;,
                                        flatlines))
                data = data.reshape(-1, ndatalines)

                # Store data
                self._pressurearrays.time[:, i] = data[:, 0]
                self._pressurearrays.valve[:, i] = data[:, npresslines+1]
                self._pressurearrays.camera[:, i] = data[:, npresslines+2]
                for j in range(1, npresslines+1):
                    exec(&#39;self._pressurearrays.pressure&#39; + str(j) +
                         &#39;.voltage[:, i] = data[: ,&#39; + str(j) + &#39;]&#39;)

        print(&#39;Done loading pressure data\n\n&#39;)

    def _loadpictures(self,
                      nblocks: int,
                      nframesperset: int,
                      imagestoload: list = None,
                      folderstoload: list = None,
                      verb: bool = False,
                      parset: bool = True,
                      zerosetload: bool = False,
                      fullparfoldersetload: bool = False):
        &#34;&#34;&#34;Load raw images.

        Parameters
        ----------
        nblocks : int :
            number of data block = number of folders with images

        nframesperset : int :
            number of images per folder

        imagestoload : list :
             (Default value = None)
             a list with the pictures indicies to load from each folder

        folderstoload : list :
             (Default value = None)
             a list of the folder paths that should be used in the loading

        verb : bool :
             (Default value = False)
             verbosity of code. False is no info, True is folder progress

        parset : bool :
             (Default value = True)
             if the loading process should be threaded, True or False

        zerosetload : bool :
             (Default value = False)
             if the load sequence is for zeroparticles folder

        fullparfoldersetload : bool :
             (Default value = False)
             if the load sequence is for a folder with full particles

        Returns
        -------
        type : numpy.ndarray :
            raw image arrayes loaded
        &#34;&#34;&#34;
        # Initialize image array to return
        imarray = np.ones((self.fileinfo.imagedata.frameheight, self.fileinfo.imagedata.framewidth,
                           nframesperset, nblocks), dtype=np.uint16)

        if verb:
            foldrange = tqdm(range(nblocks))
            if zerosetload:
                picrange = tqdm(range(nframesperset))
            else:
                picrange = range(nframesperset)
        else:
            foldrange = range(nblocks)
            picrange = range(nframesperset)

        if zerosetload:
            usefolders, useimages = _folderfind(self, self.fileinfo.zeroparticlesfolder)
        elif fullparfoldersetload:
            usefolders, useimages = _folderfind(self, self.fileinfo.fullparticlesfolder)
        else:
            usefolders = folderstoload
            useimages = imagestoload

        # Finding file paths and files in each path
        filepaths = [ph.join(self._imagesfullpath, searchfolder) for searchfolder in usefolders]
        filesinpath = [glob(filepath + f&#34;/**/*{self.fileinfo.imagedata.fileformat}&#34;, recursive=True)
                       for filepath in filepaths]

        # Sorting to ensure correct file order
        [naturalkeysort(filelists) for filelists in filesinpath]

        # finding the images to load
        filesinpath = [[filesinpath[i][x] for x in useimages] for i in range(len(filesinpath))]

        if not parset:
            for j in foldrange:
                for i in picrange:
                    _loadimagestoarray(imarray, i, j, filesinpath)
        else:
            Parallel(n_jobs=cpu_count(), require=&#34;sharedmem&#34;)(
                delayed(_loadimagestoarray)(imarray, i, j, filesinpath) for j in foldrange for i
                in picrange)

        return imarray


def _loadimagestoarray(array, k, p, filesinpathlist):
    &#34;&#34;&#34;Load images with the cv2 package, ready for parallization.

    Parameters
    ----------
    array : :
        array to fill with data

    k : :
        the time series idx

    p : :
        the dataset idx

    filesinpathlist : :
        the total file paths for each image
    &#34;&#34;&#34;
    array[:, :, k, p] = imread(filesinpathlist[p][k], IMREAD_UNCHANGED)


def _folderfind(obj, foldername):
    &#34;&#34;&#34;Find a specific folder if zero or full particles are needed.

    Parameters
    ----------
    obj : :
        the self object

    foldername : :
        substring name on the folder

    Returns
    -------
    usefolder : list :
        is the full foldername found

    useimagerange : :
        is the number of images in the folder in a range container
    &#34;&#34;&#34;
    # creating the imagefilespath
    imfiledir = ph.join(obj.fileinfo.mainpath, obj.fileinfo.imagefoldername)
    # Checking if the sero particle folder given exist in any of the dataset directory
    # folder names
    usefolder = find_dir_contains(imfiledir, foldername)

    fileexten = obj.fileinfo.imagedata.fileformat
    useimageslen = len(fnmatch.filter(listdir(ph.join(imfiledir, usefolder[0])),
                                      &#39;*&#39; + fileexten + &#39;*&#39;))
    useimagerange = range(0, useimageslen)
    return usefolder, useimagerange</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pimged.datahandling.dataloading.Dataload"><code class="flex name class">
<span>class <span class="ident">Dataload</span></span>
<span>(</span><span>imagearrays: <a title="pimged.datahandling.datacontainers.Imagearrays" href="datacontainers.html#pimged.datahandling.datacontainers.Imagearrays">Imagearrays</a>, pressurearrays: <a title="pimged.datahandling.datacontainers.Pressurearrays" href="datacontainers.html#pimged.datahandling.datacontainers.Pressurearrays">Pressurearrays</a>, fileinfo: <a title="pimged.datahandling.datacontainers.Filesinfo" href="datacontainers.html#pimged.datahandling.datacontainers.Filesinfo">Filesinfo</a>, mainpath: str, imagesearchfolders: list, zeroparticlesfolder: str, pressuresearchfolders: list = None, imagefoldername: str = None, pressurefoldername: str = '', fullparticlesfolder: str = '', errignor: bool = True, checkmeta: bool = True, loadmeta: bool = True)</span>
</code></dt>
<dd>
<div class="desc"><p>Class for loading data into a dataset struct for the PImGED framework.</p>
<p>Class to handle all functions and data for dataloading.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>imagearrays</code></strong> :&ensp;<code>pimged.Imarrays :</code></dt>
<dd>REQUIERED
all imagearray data input as the Imagearrays object</dd>
<dt><strong><code>pressurearrays</code></strong> :&ensp;<code>pimged.Pressurearrays :</code></dt>
<dd>REQUIERED
all pressure array data</dd>
<dt><strong><code>fileinfo</code></strong> :&ensp;<code>pimged.Fileinfo :</code></dt>
<dd>REQUIERED
file metadata for loaded files as the Filesinfo object</dd>
<dt><strong><code>mainpath</code></strong> :&ensp;<code>str :</code></dt>
<dd>REQUIERED
The main directory path where the image folder and pressure folders are positioned</dd>
<dt><strong><code>imagefoldername</code></strong> :&ensp;<code>str :</code></dt>
<dd>REQUIRED
foldername inside the main path containing the imagefolders</dd>
<dt><strong><code>imagesearchfolders</code></strong> :&ensp;<code>list :</code></dt>
<dd>REQUIERED
list of the folders present in the image folder that contain the images for the dataset</dd>
<dt><strong><code>zeroparticlesfolder</code></strong> :&ensp;<code>str :</code></dt>
<dd>REQUIRED
name of the folder with the initial images without particles</dd>
<dt><strong><code>pressurefoldername</code></strong> :&ensp;<code>str :</code></dt>
<dd>OPTIONAL
(Default value = '')
foldername inside the main path for the pressure datasets</dd>
<dt><strong><code>pressuresearchfolders</code></strong> :&ensp;<code>list :</code></dt>
<dd>OPTIONAL
list of folders present in the main path that contain the pressure data for the image
series. (can be left out)</dd>
<dt><strong><code>fullparticlesfolder</code></strong> :&ensp;<code>str :</code></dt>
<dd>OPTIONAL
(Default value = '')
If given the code use this folder for all calibrations of densities. It is
adviced not to use this function, may be depricated later</dd>
<dt><strong><code>errignor</code></strong> :&ensp;<code>bool :</code></dt>
<dd>(Default value = True)
false - raise error if not all inifiles have the same image and camera data,
true - show warning</dd>
<dt><strong><code>checkmeta</code></strong> :&ensp;<code>bool :</code></dt>
<dd>(Default value = True)
true - check if dataseries metadata should be compared for series integrety
flase - no check</dd>
<dt><strong><code>loadmeta</code></strong> :&ensp;<code>bool :</code></dt>
<dd>(Default value = True)
If the metadata should be loaded</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Dataload:
    &#34;&#34;&#34;Class for loading data into a dataset struct for the PImGED framework.&#34;&#34;&#34;

    def __init__(self,
                 imagearrays: Imagearrays,
                 pressurearrays: Pressurearrays,
                 fileinfo: Filesinfo,
                 mainpath: str,
                 imagesearchfolders: list,
                 zeroparticlesfolder: str,
                 pressuresearchfolders: list = None,
                 imagefoldername: str = None,
                 pressurefoldername: str = &#34;&#34;,
                 fullparticlesfolder: str = &#34;&#34;,
                 errignor: bool = True,
                 checkmeta: bool = True,
                 loadmeta: bool = True):
        &#34;&#34;&#34;Class to handle all functions and data for dataloading.

        Parameters
        ----------
        imagearrays : pimged.Imarrays :
            REQUIERED
            all imagearray data input as the Imagearrays object

        pressurearrays : pimged.Pressurearrays :
            REQUIERED
            all pressure array data

        fileinfo : pimged.Fileinfo :
            REQUIERED
            file metadata for loaded files as the Filesinfo object

        mainpath : str :
            REQUIERED
            The main directory path where the image folder and pressure folders are positioned

        imagefoldername : str :
            REQUIRED
            foldername inside the main path containing the imagefolders

        imagesearchfolders : list :
            REQUIERED
            list of the folders present in the image folder that contain the images for the dataset

        zeroparticlesfolder : str :
            REQUIRED
            name of the folder with the initial images without particles

        pressurefoldername : str :
            OPTIONAL
            (Default value = &#39;&#39;)
            foldername inside the main path for the pressure datasets

        pressuresearchfolders : list :
            OPTIONAL
            list of folders present in the main path that contain the pressure data for the image
            series. (can be left out)

        fullparticlesfolder : str :
            OPTIONAL
            (Default value = &#39;&#39;)
            If given the code use this folder for all calibrations of densities. It is
            adviced not to use this function, may be depricated later

        errignor : bool :
            (Default value = True)
            false - raise error if not all inifiles have the same image and camera data,
            true - show warning

        checkmeta : bool :
            (Default value = True)
            true - check if dataseries metadata should be compared for series integrety
            flase - no check

        loadmeta : bool :
            (Default value = True)
            If the metadata should be loaded
        &#34;&#34;&#34;
        self.fileinfo = fileinfo
        self.fileinfo.mainpath = mainpath
        self.fileinfo.imagesearchfolders = imagesearchfolders
        self.fileinfo.imagefoldername = imagefoldername
        self.fileinfo.pressuresearchfolders = pressurefoldername
        self.fileinfo.pressuresearchfolders = pressuresearchfolders
        self.fileinfo.zeroparticlesfolder = zeroparticlesfolder
        self.fileinfo.fullparticlesfolder = fullparticlesfolder
        self.fileinfo.errignor = errignor

        self._imagearrays = imagearrays
        self._pressurearrays = pressurearrays
        self._imagesfullpath = ph.join(mainpath, imagefoldername)
        self._pressuresfullpath = ph.join(mainpath, pressurefoldername)

        # IF THE CODE SHOULD BE MODIFIED FOR DATA WITHOUT CHIX FILES, MAKE A CHECK THAT IGNORES
        # THE LINES BELOW
        if checkmeta:
            # Checking if the datahandling is coherent in accusition setup
            checkingchixfileset(self._imagesfullpath, imagesearchfolders, errignor)

        if loadmeta:
            # If the files are approved, the camera and image data from the first files is read and
            # a list of each datahandling start recording times
            print(&#39;Loading chosen files meta data&#39;)
            self.fileinfo.imagedata = ImageData(self._imagesfullpath, imagesearchfolders)
            self.fileinfo.cameradata = CameraData(self._imagesfullpath, imagesearchfolders)
            print(&#39;Done\n\n&#39;)

    def loadimages(self,
                   loadzeroimages: bool = False,
                   setfolderstoload: list = &#39;all&#39;,
                   setimagestoload: list = &#39;all&#39;,
                   verb: bool = False,
                   loadmethodfolder: str = &#39;range&#39;,
                   loadmethodimage: str = &#39;range&#39;,
                   parset: bool = True,
                   natkeysort: bool = True):
        &#34;&#34;&#34;Load data from set of images exported from PFV with a cihx inifile.

        The loaded data is populated in the raw image datacontainer of the dataset and contain
        data with 4 dimensions.
        ndarray([H, W, Time, Statio. time])

        #### H:
        is the height of the image in pixel

        #### W:
        is the width in pixel

        #### Time:
        is progress in time for each repetition

        #### Statio. time:
        is the repetition of datasets stationary in time


        It is demanded that all datasets given have the same number of images in the folder

        Parameters
        ----------
        loadzeroimages : bool :
             (Default value = False)
            if the zero images of the datasetshould be loaded in

        setfolderstoload : list :
             (Default value = &#39;all&#39;)
            input has to be a list with start and end index of folders to load
            in path.

        setimagestoload : list :
             (Default value = &#39;all&#39;)
            input has to be a list with start and end index of images in sets to
            load in path

        verb : bool :
             (Default value = False)
            verbosity of code. False is no info, True is folder progress

        loadmethodfolder : str :
             (Default value = &#39;range&#39;)
            {&#39;range&#39;, &#39;spec&#39;}
            how to intrepreate the set inputs.
            &#39;range&#39; take first and last element of lists to create a range to loop,
            &#39;spec&#39; setting use the given list as a specific list of positions to load
            images and folders

        loadmethodimage : str :
             (Default value = &#39;range&#39;)
            {&#39;range&#39;, &#39;spec&#39;}
            how to intrepreate the set inputs.
            &#39;range&#39; take first and last element of lists to create a range to loop,
            &#39;spec&#39; setting use the given list as a specific list of positions to load images and
            folders

        parset : bool :
             (Default value = True)
            if the loading process should be threaded, True or False

        natkeysort : bool :
             (Default value = True)
            if the seachfolder input list should be sorted according to the
            natural key method

        Raises
        ------
        AttributeError : :
            If image metadata is not loaded
        &#34;&#34;&#34;
        if not hasattr(self.fileinfo.imagedata, &#39;totalframes&#39;):
            raise AttributeError(&#34;Imagedata are not loaded during the initilization of the &#34;
                                 &#34;framework. Specify the maximum number of images present in &#34;
                                 &#34;the datasets by loading the metadata files at initilization.&#34;)

        if loadzeroimages:
            self._loadimageszeros(verb=True, parsetload=True)
        else:

            self.fileinfo.loadedimagerange = setimagestoload
            self.fileinfo.loadeddatasets = setfolderstoload

            maxnumimagefiles = list(range(0, self.fileinfo.imagedata.totalframes, 1))

            # Creating the new list that can be sorted without altering the orignal info
            sortedfolderlist = self.fileinfo.imagesearchfolders.copy()
            if natkeysort:
                naturalkeysort(sortedfolderlist)

            folderstoload = range_load_check(sortedfolderlist,
                                             setfolderstoload,
                                             &#39;all&#39;,
                                             list,
                                             loadmethodfolder)
            imagestoload = range_load_check(maxnumimagefiles,
                                            setimagestoload,
                                            &#39;all&#39;,
                                            list,
                                            loadmethodimage)

            nblocksload = len(folderstoload)
            nframesperset = len(imagestoload)

            print(&#39;Starting to load image data&#39;)

            self._imagearrays.raw.data = self._loadpictures(nblocks=nblocksload,
                                                            nframesperset=nframesperset,
                                                            verb=verb,
                                                            parset=parset,
                                                            imagestoload=imagestoload,
                                                            folderstoload=folderstoload)

            # updating the raw image info
            self._imagearrays.raw.arrayinfo.loadeddatasets = [setfolderstoload[0],
                                                              setfolderstoload[0]+nblocksload-1]
            if len(setimagestoload) == 1:
                self._imagearrays.raw.arrayinfo.loadedimagerange = [setimagestoload[0],
                                                                    setimagestoload[0]]
            else:
                self._imagearrays.raw.arrayinfo.loadedimagerange = [setimagestoload[0],
                                                                    setimagestoload[1]]

    def _loadimageszeros(self, verb: bool = True, parsetload: bool = True):
        &#34;&#34;&#34;Shortcut function for loading zero images.

        Parameters
        ----------
        verb : bool :
             (Default value = True)
            verbosity of code. False is no info, True is folder progress

        parsetload : bool :
             (Default value = True)
            if the loading process should be threaded, True or False

        Raises
        ------
        NotADirectoryError : :
            The provided zero particle folder do not exist
        &#34;&#34;&#34;
        # creating the imagefilespath
        imfiledir = ph.join(self.fileinfo.mainpath, self.fileinfo.imagefoldername)

        # Checking if the sero particle folder given exist in any of the dataset directory
        # folder names
        pathforzeroparticleimages = get_folder_paths(imfiledir,
                                                     self.fileinfo.zeroparticlesfolder)[0]

        if not ph.exists(pathforzeroparticleimages):
            raise NotADirectoryError(&#34;The given zero particle folder do not exist&#34;)

        # Setting blocks and images in the zero particles images folder
        nblockperload = 1
        nframespersetzero = len(find_dir_contains(pathforzeroparticleimages,
                                                  self.fileinfo.imagedata.fileformat))

        # Loading zero particle images
        print(&#39;Loading Zero particle images&#39;)
        # noinspection PyProtectedMember
        self._imagearrays.zero.data = \
            self._loadpictures(nblockperload,
                               nframespersetzero,
                               verb=verb,
                               zerosetload=True,
                               parset=parsetload)

        self._imagearrays.zero.arrayinfo.loadeddatasets = [1, 1]
        self._imagearrays.zero.arrayinfo.loadedimagerange = [1, nframespersetzero]

        print(&#39;Done loading images\n\n&#39;)

    def loadpressuresOLD(self,
                         setfilestoload: list = &#39;all&#39;,
                         natkeysort: bool = True,
                         loadmethodfolder: str = &#39;range&#39;,
                         ndatalines: int = 5,
                         npresslines: int = 3):
        &#34;&#34;&#34;Load data into the pressure, time and vale signal into the pressure arrays.

        for the old pressure file setup design

        Parameters
        ----------
        setfilestoload : list :
             (Default value = &#39;all&#39;)
             list of files to load

        natkeysort : bool :
             (Default value = True)
             if the list should be sorted with natural order sorting

        loadmethodfolder : str :
             (Default value = &#39;range&#39;)
            {&#39;range&#39;, &#39;spec&#39;}
            how to intrepreate the set inputs.
            &#39;range&#39; take first and last element of lists to create a range to loop,
            &#39;spec&#39; setting use the given list as a specific list of positions to load
            images and folders

        ndatalines : int :
             (Default value = 5)
             numbder of columns with data

        npresslines : int :
             (Default value = 3)
            numboer of pressure sensors in file
        &#34;&#34;&#34;
        # File dependent info
        roominfoidx = 0
        caliblineidx = slice(3, 5)
        datarowidxstart = 7

        # Creating the new list that can be sorted without altering the orignal info
        sortedfolderlist = self.fileinfo.pressuresearchfolders.copy()
        if natkeysort:
            naturalkeysort(sortedfolderlist)

        # Cehcking for the files wanted
        pressfiles = range_load_check(sortedfolderlist, setfilestoload, &#39;all&#39;, list,
                                      loadmethodfolder)
        nblocksload = len(pressfiles)

        # Update the metadata
        self._pressurearrays.loadedpressurerange = [setfilestoload[0],
                                                    setfilestoload[0] + nblocksload - 1]

        print(&#39;Starting to load pressure data&#39;)

        # Building path to first file for reading basic info
        filepath = ph.join(self._pressuresfullpath, pressfiles[0])

        with open(filepath, &#39;r&#39;) as f:
            readlines = f.readlines()
            ndatapoints = len(readlines[datarowidxstart:])

        # noinspection PyProtectedMember
        precision = self._pressurearrays._precision_calc
        nsets = len(pressfiles)

        calibrations = np.zeros((4, 2), dtype=precision)
        self._pressurearrays.time = np.zeros((ndatapoints, nsets), dtype=precision)
        self._pressurearrays.valve = np.zeros((ndatapoints, nsets), dtype=precision)
        self._pressurearrays.temperature = np.zeros(nsets, dtype=precision)
        self._pressurearrays.pressure_atm = np.zeros(nsets, dtype=precision)
        for i in range(1, npresslines+1):
            exec(&#39;self._pressurearrays.pressure&#39; + str(i) +
                 &#39;.voltage= np.zeros((ndatapoints, nsets), dtype=precision)&#39;)
            exec(&#39;self._pressurearrays.pressure&#39; + str(i) +
                 &#39;.calibration = np.zeros((2, nsets), dtype=precision)&#39;)

        for i, file in enumerate(pressfiles):
            filepath = ph.join(self._pressuresfullpath, file)
            with open(filepath, &#39;r&#39;) as f:
                readlines = f.readlines()

                # reads the pressure and temperature in
                readnums = findall(r&#39;[+\-]?(?:0|[1-9]\d*)(?:\.\d*)?(?:[eE][+\-]?\d+)&#39;,
                                   readlines[roominfoidx].replace(&#39;,&#39;, &#39;.&#39;))
                self._pressurearrays.pressure_atm[i] = readnums[0]
                self._pressurearrays.temperature[i] = readnums[1]

                # Get the calibration data
                for j, line in enumerate(readlines[caliblineidx]):
                    listofsplits = split(r&#39;\t+&#39;, line.replace(&#39;,&#39;, &#39;.&#39;).rstrip(&#39;\n&#39;))
                    calibrations[:, j] = np.array(listofsplits)

                for j in range(1, npresslines+1):
                    exec(&#39;self._pressurearrays.pressure&#39; + str(j) +
                         &#39;.calibration[:, i] = calibrations[&#39; + str(j-1) + &#39;, :]&#39;)

                # Subtract data series from file
                flatlines = sub(&#39;,&#39;, &#39;.&#39;, &#34;&#34;.join(readlines[datarowidxstart:]))
                data = np.array(findall(r&#39;[+\-]?(?:0|[1-9]\d*)(?:\.\d*)?(?:[eE][+\-]?\d+)&#39;,
                                        flatlines))
                data = data.reshape(-1, ndatalines)

                # Store data
                self._pressurearrays.time[:, i] = data[:, 0]
                self._pressurearrays.valve[:, i] = data[:, npresslines+1]
                for j in range(1, npresslines+1):
                    exec(&#39;self._pressurearrays.pressure&#39; + str(j) +
                         &#39;.voltage[:, i] = data[: ,&#39; + str(j) + &#39;]&#39;)

        print(&#39;Done loading pressure data\n\n&#39;)

    def loadpressures(self,
                      setfilestoload: list = &#39;all&#39;,
                      natkeysort: bool = True,
                      loadmethodfolder: str = &#39;range&#39;,
                      ndatalines: int = 6,
                      npresslines: int = 3):
        &#34;&#34;&#34;Load data into the pressure, time and vale signal into the pressure arrays.

        Parameters
        ----------
        setfilestoload : list :
             (Default value = &#39;all&#39;)
             list of files to load

        natkeysort : bool :
             (Default value = True)
             if the list should be sorted with natural order sorting

        loadmethodfolder : str :
             (Default value = &#39;range&#39;)
            {&#39;range&#39;, &#39;spec&#39;}
            how to intrepreate the set inputs.
            &#39;range&#39; take first and last element of lists to create a range to loop,
            &#39;spec&#39; setting use the given list as a specific list of positions to load
            images and folders

        ndatalines : int :
             (Default value = 5)
             numbder of columns with data

        npresslines : int :
             (Default value = 3)
            numboer of pressure sensors in file
        &#34;&#34;&#34;
        # File dependent info
        roominfoidx = 0
        caliblineidx = slice(3, 5)
        datarowidxstart = 7

        # Creating the new list that can be sorted without altering the orignal info
        sortedfolderlist = self.fileinfo.pressuresearchfolders.copy()
        if natkeysort:
            naturalkeysort(sortedfolderlist)

        # Cehcking for the files wanted
        pressfiles = range_load_check(sortedfolderlist, setfilestoload, &#39;all&#39;, list,
                                      loadmethodfolder)
        nblocksload = len(pressfiles)

        # Update the metadata
        self._pressurearrays.loadedpressurerange = [setfilestoload[0],
                                                    setfilestoload[0] + nblocksload - 1]

        print(&#39;Starting to load pressure data&#39;)

        # Building path to first file for reading basic info
        filepath = ph.join(self._pressuresfullpath, pressfiles[0])

        with open(filepath, &#39;r&#39;) as f:
            readlines = f.readlines()
            ndatapoints = len(readlines[datarowidxstart:])

        # noinspection PyProtectedMember
        precision = self._pressurearrays._precision_calc
        nsets = len(pressfiles)

        calibrations = np.zeros((4, 2), dtype=precision)
        self._pressurearrays.time = np.zeros((ndatapoints, nsets), dtype=precision)
        self._pressurearrays.valve = np.zeros((ndatapoints, nsets), dtype=precision)
        self._pressurearrays.camera = np.zeros((ndatapoints, nsets), dtype=precision)
        self._pressurearrays.temperature = np.zeros(nsets, dtype=precision)
        self._pressurearrays.pressure_atm = np.zeros(nsets, dtype=precision)
        for i in range(1, npresslines+1):
            exec(&#39;self._pressurearrays.pressure&#39; + str(i) +
                 &#39;.voltage= np.zeros((ndatapoints, nsets), dtype=precision)&#39;)
            exec(&#39;self._pressurearrays.pressure&#39; + str(i) +
                 &#39;.calibration = np.zeros((2, nsets), dtype=precision)&#39;)

        for i, file in enumerate(pressfiles):
            filepath = ph.join(self._pressuresfullpath, file)
            with open(filepath, &#39;r&#39;) as f:
                readlines = f.readlines()

                # reads the pressure and temperature in
                readnums = findall(r&#39;[+\-]?(?:0|[1-9]\d*)(?:\.\d*)?(?:[eE][+\-]?\d+)&#39;,
                                   readlines[roominfoidx].replace(&#39;,&#39;, &#39;.&#39;))
                self._pressurearrays.pressure_atm[i] = readnums[0]
                self._pressurearrays.temperature[i] = readnums[1]

                # Get the calibration data
                for j, line in enumerate(readlines[caliblineidx]):
                    listofsplits = split(r&#39;\t+&#39;, line.replace(&#39;,&#39;, &#39;.&#39;).rstrip(&#39;\n&#39;))
                    calibrations[:, j] = np.array(listofsplits)

                for j in range(1, npresslines+1):
                    exec(&#39;self._pressurearrays.pressure&#39; + str(j) +
                         &#39;.calibration[:, i] = calibrations[&#39; + str(j-1) + &#39;, :]&#39;)

                # Subtract data series from file
                flatlines = sub(&#39;,&#39;, &#39;.&#39;, &#34;&#34;.join(readlines[datarowidxstart:]))
                data = np.array(findall(r&#39;[+\-]?(?:0|[1-9]\d*)(?:\.\d*)?(?:[eE][+\-]?\d+)&#39;,
                                        flatlines))
                data = data.reshape(-1, ndatalines)

                # Store data
                self._pressurearrays.time[:, i] = data[:, 0]
                self._pressurearrays.valve[:, i] = data[:, npresslines+1]
                self._pressurearrays.camera[:, i] = data[:, npresslines+2]
                for j in range(1, npresslines+1):
                    exec(&#39;self._pressurearrays.pressure&#39; + str(j) +
                         &#39;.voltage[:, i] = data[: ,&#39; + str(j) + &#39;]&#39;)

        print(&#39;Done loading pressure data\n\n&#39;)

    def _loadpictures(self,
                      nblocks: int,
                      nframesperset: int,
                      imagestoload: list = None,
                      folderstoload: list = None,
                      verb: bool = False,
                      parset: bool = True,
                      zerosetload: bool = False,
                      fullparfoldersetload: bool = False):
        &#34;&#34;&#34;Load raw images.

        Parameters
        ----------
        nblocks : int :
            number of data block = number of folders with images

        nframesperset : int :
            number of images per folder

        imagestoload : list :
             (Default value = None)
             a list with the pictures indicies to load from each folder

        folderstoload : list :
             (Default value = None)
             a list of the folder paths that should be used in the loading

        verb : bool :
             (Default value = False)
             verbosity of code. False is no info, True is folder progress

        parset : bool :
             (Default value = True)
             if the loading process should be threaded, True or False

        zerosetload : bool :
             (Default value = False)
             if the load sequence is for zeroparticles folder

        fullparfoldersetload : bool :
             (Default value = False)
             if the load sequence is for a folder with full particles

        Returns
        -------
        type : numpy.ndarray :
            raw image arrayes loaded
        &#34;&#34;&#34;
        # Initialize image array to return
        imarray = np.ones((self.fileinfo.imagedata.frameheight, self.fileinfo.imagedata.framewidth,
                           nframesperset, nblocks), dtype=np.uint16)

        if verb:
            foldrange = tqdm(range(nblocks))
            if zerosetload:
                picrange = tqdm(range(nframesperset))
            else:
                picrange = range(nframesperset)
        else:
            foldrange = range(nblocks)
            picrange = range(nframesperset)

        if zerosetload:
            usefolders, useimages = _folderfind(self, self.fileinfo.zeroparticlesfolder)
        elif fullparfoldersetload:
            usefolders, useimages = _folderfind(self, self.fileinfo.fullparticlesfolder)
        else:
            usefolders = folderstoload
            useimages = imagestoload

        # Finding file paths and files in each path
        filepaths = [ph.join(self._imagesfullpath, searchfolder) for searchfolder in usefolders]
        filesinpath = [glob(filepath + f&#34;/**/*{self.fileinfo.imagedata.fileformat}&#34;, recursive=True)
                       for filepath in filepaths]

        # Sorting to ensure correct file order
        [naturalkeysort(filelists) for filelists in filesinpath]

        # finding the images to load
        filesinpath = [[filesinpath[i][x] for x in useimages] for i in range(len(filesinpath))]

        if not parset:
            for j in foldrange:
                for i in picrange:
                    _loadimagestoarray(imarray, i, j, filesinpath)
        else:
            Parallel(n_jobs=cpu_count(), require=&#34;sharedmem&#34;)(
                delayed(_loadimagestoarray)(imarray, i, j, filesinpath) for j in foldrange for i
                in picrange)

        return imarray</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="pimged.datahandling.dataset.Dataset" href="dataset.html#pimged.datahandling.dataset.Dataset">Dataset</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pimged.datahandling.dataloading.Dataload.loadimages"><code class="name flex">
<span>def <span class="ident">loadimages</span></span>(<span>self, loadzeroimages: bool = False, setfolderstoload: list = 'all', setimagestoload: list = 'all', verb: bool = False, loadmethodfolder: str = 'range', loadmethodimage: str = 'range', parset: bool = True, natkeysort: bool = True)</span>
</code></dt>
<dd>
<div class="desc"><p>Load data from set of images exported from PFV with a cihx inifile.</p>
<p>The loaded data is populated in the raw image datacontainer of the dataset and contain
data with 4 dimensions.
ndarray([H, W, Time, Statio. time])</p>
<h4 id="h">H:</h4>
<p>is the height of the image in pixel</p>
<h4 id="w">W:</h4>
<p>is the width in pixel</p>
<h4 id="time">Time:</h4>
<p>is progress in time for each repetition</p>
<h4 id="statio-time">Statio. time:</h4>
<p>is the repetition of datasets stationary in time</p>
<p>It is demanded that all datasets given have the same number of images in the folder</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>loadzeroimages</code></strong> :&ensp;<code>bool :</code></dt>
<dd>(Default value = False)
if the zero images of the datasetshould be loaded in</dd>
<dt><strong><code>setfolderstoload</code></strong> :&ensp;<code>list :</code></dt>
<dd>(Default value = 'all')
input has to be a list with start and end index of folders to load
in path.</dd>
<dt><strong><code>setimagestoload</code></strong> :&ensp;<code>list :</code></dt>
<dd>(Default value = 'all')
input has to be a list with start and end index of images in sets to
load in path</dd>
<dt><strong><code>verb</code></strong> :&ensp;<code>bool :</code></dt>
<dd>(Default value = False)
verbosity of code. False is no info, True is folder progress</dd>
<dt><strong><code>loadmethodfolder</code></strong> :&ensp;<code>str :</code></dt>
<dd>(Default value = 'range')
{'range', 'spec'}
how to intrepreate the set inputs.
'range' take first and last element of lists to create a range to loop,
'spec' setting use the given list as a specific list of positions to load
images and folders</dd>
<dt><strong><code>loadmethodimage</code></strong> :&ensp;<code>str :</code></dt>
<dd>(Default value = 'range')
{'range', 'spec'}
how to intrepreate the set inputs.
'range' take first and last element of lists to create a range to loop,
'spec' setting use the given list as a specific list of positions to load images and
folders</dd>
<dt><strong><code>parset</code></strong> :&ensp;<code>bool :</code></dt>
<dd>(Default value = True)
if the loading process should be threaded, True or False</dd>
<dt><strong><code>natkeysort</code></strong> :&ensp;<code>bool :</code></dt>
<dd>(Default value = True)
if the seachfolder input list should be sorted according to the
natural key method</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><strong><code>AttributeError</code></strong> :&ensp;<code>:</code></dt>
<dd>If image metadata is not loaded</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def loadimages(self,
               loadzeroimages: bool = False,
               setfolderstoload: list = &#39;all&#39;,
               setimagestoload: list = &#39;all&#39;,
               verb: bool = False,
               loadmethodfolder: str = &#39;range&#39;,
               loadmethodimage: str = &#39;range&#39;,
               parset: bool = True,
               natkeysort: bool = True):
    &#34;&#34;&#34;Load data from set of images exported from PFV with a cihx inifile.

    The loaded data is populated in the raw image datacontainer of the dataset and contain
    data with 4 dimensions.
    ndarray([H, W, Time, Statio. time])

    #### H:
    is the height of the image in pixel

    #### W:
    is the width in pixel

    #### Time:
    is progress in time for each repetition

    #### Statio. time:
    is the repetition of datasets stationary in time


    It is demanded that all datasets given have the same number of images in the folder

    Parameters
    ----------
    loadzeroimages : bool :
         (Default value = False)
        if the zero images of the datasetshould be loaded in

    setfolderstoload : list :
         (Default value = &#39;all&#39;)
        input has to be a list with start and end index of folders to load
        in path.

    setimagestoload : list :
         (Default value = &#39;all&#39;)
        input has to be a list with start and end index of images in sets to
        load in path

    verb : bool :
         (Default value = False)
        verbosity of code. False is no info, True is folder progress

    loadmethodfolder : str :
         (Default value = &#39;range&#39;)
        {&#39;range&#39;, &#39;spec&#39;}
        how to intrepreate the set inputs.
        &#39;range&#39; take first and last element of lists to create a range to loop,
        &#39;spec&#39; setting use the given list as a specific list of positions to load
        images and folders

    loadmethodimage : str :
         (Default value = &#39;range&#39;)
        {&#39;range&#39;, &#39;spec&#39;}
        how to intrepreate the set inputs.
        &#39;range&#39; take first and last element of lists to create a range to loop,
        &#39;spec&#39; setting use the given list as a specific list of positions to load images and
        folders

    parset : bool :
         (Default value = True)
        if the loading process should be threaded, True or False

    natkeysort : bool :
         (Default value = True)
        if the seachfolder input list should be sorted according to the
        natural key method

    Raises
    ------
    AttributeError : :
        If image metadata is not loaded
    &#34;&#34;&#34;
    if not hasattr(self.fileinfo.imagedata, &#39;totalframes&#39;):
        raise AttributeError(&#34;Imagedata are not loaded during the initilization of the &#34;
                             &#34;framework. Specify the maximum number of images present in &#34;
                             &#34;the datasets by loading the metadata files at initilization.&#34;)

    if loadzeroimages:
        self._loadimageszeros(verb=True, parsetload=True)
    else:

        self.fileinfo.loadedimagerange = setimagestoload
        self.fileinfo.loadeddatasets = setfolderstoload

        maxnumimagefiles = list(range(0, self.fileinfo.imagedata.totalframes, 1))

        # Creating the new list that can be sorted without altering the orignal info
        sortedfolderlist = self.fileinfo.imagesearchfolders.copy()
        if natkeysort:
            naturalkeysort(sortedfolderlist)

        folderstoload = range_load_check(sortedfolderlist,
                                         setfolderstoload,
                                         &#39;all&#39;,
                                         list,
                                         loadmethodfolder)
        imagestoload = range_load_check(maxnumimagefiles,
                                        setimagestoload,
                                        &#39;all&#39;,
                                        list,
                                        loadmethodimage)

        nblocksload = len(folderstoload)
        nframesperset = len(imagestoload)

        print(&#39;Starting to load image data&#39;)

        self._imagearrays.raw.data = self._loadpictures(nblocks=nblocksload,
                                                        nframesperset=nframesperset,
                                                        verb=verb,
                                                        parset=parset,
                                                        imagestoload=imagestoload,
                                                        folderstoload=folderstoload)

        # updating the raw image info
        self._imagearrays.raw.arrayinfo.loadeddatasets = [setfolderstoload[0],
                                                          setfolderstoload[0]+nblocksload-1]
        if len(setimagestoload) == 1:
            self._imagearrays.raw.arrayinfo.loadedimagerange = [setimagestoload[0],
                                                                setimagestoload[0]]
        else:
            self._imagearrays.raw.arrayinfo.loadedimagerange = [setimagestoload[0],
                                                                setimagestoload[1]]</code></pre>
</details>
</dd>
<dt id="pimged.datahandling.dataloading.Dataload.loadpressures"><code class="name flex">
<span>def <span class="ident">loadpressures</span></span>(<span>self, setfilestoload: list = 'all', natkeysort: bool = True, loadmethodfolder: str = 'range', ndatalines: int = 6, npresslines: int = 3)</span>
</code></dt>
<dd>
<div class="desc"><p>Load data into the pressure, time and vale signal into the pressure arrays.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>setfilestoload</code></strong> :&ensp;<code>list :</code></dt>
<dd>(Default value = 'all')
list of files to load</dd>
<dt><strong><code>natkeysort</code></strong> :&ensp;<code>bool :</code></dt>
<dd>(Default value = True)
if the list should be sorted with natural order sorting</dd>
<dt><strong><code>loadmethodfolder</code></strong> :&ensp;<code>str :</code></dt>
<dd>(Default value = 'range')
{'range', 'spec'}
how to intrepreate the set inputs.
'range' take first and last element of lists to create a range to loop,
'spec' setting use the given list as a specific list of positions to load
images and folders</dd>
<dt><strong><code>ndatalines</code></strong> :&ensp;<code>int :</code></dt>
<dd>(Default value = 5)
numbder of columns with data</dd>
<dt><strong><code>npresslines</code></strong> :&ensp;<code>int :</code></dt>
<dd>(Default value = 3)
numboer of pressure sensors in file</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def loadpressures(self,
                  setfilestoload: list = &#39;all&#39;,
                  natkeysort: bool = True,
                  loadmethodfolder: str = &#39;range&#39;,
                  ndatalines: int = 6,
                  npresslines: int = 3):
    &#34;&#34;&#34;Load data into the pressure, time and vale signal into the pressure arrays.

    Parameters
    ----------
    setfilestoload : list :
         (Default value = &#39;all&#39;)
         list of files to load

    natkeysort : bool :
         (Default value = True)
         if the list should be sorted with natural order sorting

    loadmethodfolder : str :
         (Default value = &#39;range&#39;)
        {&#39;range&#39;, &#39;spec&#39;}
        how to intrepreate the set inputs.
        &#39;range&#39; take first and last element of lists to create a range to loop,
        &#39;spec&#39; setting use the given list as a specific list of positions to load
        images and folders

    ndatalines : int :
         (Default value = 5)
         numbder of columns with data

    npresslines : int :
         (Default value = 3)
        numboer of pressure sensors in file
    &#34;&#34;&#34;
    # File dependent info
    roominfoidx = 0
    caliblineidx = slice(3, 5)
    datarowidxstart = 7

    # Creating the new list that can be sorted without altering the orignal info
    sortedfolderlist = self.fileinfo.pressuresearchfolders.copy()
    if natkeysort:
        naturalkeysort(sortedfolderlist)

    # Cehcking for the files wanted
    pressfiles = range_load_check(sortedfolderlist, setfilestoload, &#39;all&#39;, list,
                                  loadmethodfolder)
    nblocksload = len(pressfiles)

    # Update the metadata
    self._pressurearrays.loadedpressurerange = [setfilestoload[0],
                                                setfilestoload[0] + nblocksload - 1]

    print(&#39;Starting to load pressure data&#39;)

    # Building path to first file for reading basic info
    filepath = ph.join(self._pressuresfullpath, pressfiles[0])

    with open(filepath, &#39;r&#39;) as f:
        readlines = f.readlines()
        ndatapoints = len(readlines[datarowidxstart:])

    # noinspection PyProtectedMember
    precision = self._pressurearrays._precision_calc
    nsets = len(pressfiles)

    calibrations = np.zeros((4, 2), dtype=precision)
    self._pressurearrays.time = np.zeros((ndatapoints, nsets), dtype=precision)
    self._pressurearrays.valve = np.zeros((ndatapoints, nsets), dtype=precision)
    self._pressurearrays.camera = np.zeros((ndatapoints, nsets), dtype=precision)
    self._pressurearrays.temperature = np.zeros(nsets, dtype=precision)
    self._pressurearrays.pressure_atm = np.zeros(nsets, dtype=precision)
    for i in range(1, npresslines+1):
        exec(&#39;self._pressurearrays.pressure&#39; + str(i) +
             &#39;.voltage= np.zeros((ndatapoints, nsets), dtype=precision)&#39;)
        exec(&#39;self._pressurearrays.pressure&#39; + str(i) +
             &#39;.calibration = np.zeros((2, nsets), dtype=precision)&#39;)

    for i, file in enumerate(pressfiles):
        filepath = ph.join(self._pressuresfullpath, file)
        with open(filepath, &#39;r&#39;) as f:
            readlines = f.readlines()

            # reads the pressure and temperature in
            readnums = findall(r&#39;[+\-]?(?:0|[1-9]\d*)(?:\.\d*)?(?:[eE][+\-]?\d+)&#39;,
                               readlines[roominfoidx].replace(&#39;,&#39;, &#39;.&#39;))
            self._pressurearrays.pressure_atm[i] = readnums[0]
            self._pressurearrays.temperature[i] = readnums[1]

            # Get the calibration data
            for j, line in enumerate(readlines[caliblineidx]):
                listofsplits = split(r&#39;\t+&#39;, line.replace(&#39;,&#39;, &#39;.&#39;).rstrip(&#39;\n&#39;))
                calibrations[:, j] = np.array(listofsplits)

            for j in range(1, npresslines+1):
                exec(&#39;self._pressurearrays.pressure&#39; + str(j) +
                     &#39;.calibration[:, i] = calibrations[&#39; + str(j-1) + &#39;, :]&#39;)

            # Subtract data series from file
            flatlines = sub(&#39;,&#39;, &#39;.&#39;, &#34;&#34;.join(readlines[datarowidxstart:]))
            data = np.array(findall(r&#39;[+\-]?(?:0|[1-9]\d*)(?:\.\d*)?(?:[eE][+\-]?\d+)&#39;,
                                    flatlines))
            data = data.reshape(-1, ndatalines)

            # Store data
            self._pressurearrays.time[:, i] = data[:, 0]
            self._pressurearrays.valve[:, i] = data[:, npresslines+1]
            self._pressurearrays.camera[:, i] = data[:, npresslines+2]
            for j in range(1, npresslines+1):
                exec(&#39;self._pressurearrays.pressure&#39; + str(j) +
                     &#39;.voltage[:, i] = data[: ,&#39; + str(j) + &#39;]&#39;)

    print(&#39;Done loading pressure data\n\n&#39;)</code></pre>
</details>
</dd>
<dt id="pimged.datahandling.dataloading.Dataload.loadpressuresOLD"><code class="name flex">
<span>def <span class="ident">loadpressuresOLD</span></span>(<span>self, setfilestoload: list = 'all', natkeysort: bool = True, loadmethodfolder: str = 'range', ndatalines: int = 5, npresslines: int = 3)</span>
</code></dt>
<dd>
<div class="desc"><p>Load data into the pressure, time and vale signal into the pressure arrays.</p>
<p>for the old pressure file setup design</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>setfilestoload</code></strong> :&ensp;<code>list :</code></dt>
<dd>(Default value = 'all')
list of files to load</dd>
<dt><strong><code>natkeysort</code></strong> :&ensp;<code>bool :</code></dt>
<dd>(Default value = True)
if the list should be sorted with natural order sorting</dd>
<dt><strong><code>loadmethodfolder</code></strong> :&ensp;<code>str :</code></dt>
<dd>(Default value = 'range')
{'range', 'spec'}
how to intrepreate the set inputs.
'range' take first and last element of lists to create a range to loop,
'spec' setting use the given list as a specific list of positions to load
images and folders</dd>
<dt><strong><code>ndatalines</code></strong> :&ensp;<code>int :</code></dt>
<dd>(Default value = 5)
numbder of columns with data</dd>
<dt><strong><code>npresslines</code></strong> :&ensp;<code>int :</code></dt>
<dd>(Default value = 3)
numboer of pressure sensors in file</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def loadpressuresOLD(self,
                     setfilestoload: list = &#39;all&#39;,
                     natkeysort: bool = True,
                     loadmethodfolder: str = &#39;range&#39;,
                     ndatalines: int = 5,
                     npresslines: int = 3):
    &#34;&#34;&#34;Load data into the pressure, time and vale signal into the pressure arrays.

    for the old pressure file setup design

    Parameters
    ----------
    setfilestoload : list :
         (Default value = &#39;all&#39;)
         list of files to load

    natkeysort : bool :
         (Default value = True)
         if the list should be sorted with natural order sorting

    loadmethodfolder : str :
         (Default value = &#39;range&#39;)
        {&#39;range&#39;, &#39;spec&#39;}
        how to intrepreate the set inputs.
        &#39;range&#39; take first and last element of lists to create a range to loop,
        &#39;spec&#39; setting use the given list as a specific list of positions to load
        images and folders

    ndatalines : int :
         (Default value = 5)
         numbder of columns with data

    npresslines : int :
         (Default value = 3)
        numboer of pressure sensors in file
    &#34;&#34;&#34;
    # File dependent info
    roominfoidx = 0
    caliblineidx = slice(3, 5)
    datarowidxstart = 7

    # Creating the new list that can be sorted without altering the orignal info
    sortedfolderlist = self.fileinfo.pressuresearchfolders.copy()
    if natkeysort:
        naturalkeysort(sortedfolderlist)

    # Cehcking for the files wanted
    pressfiles = range_load_check(sortedfolderlist, setfilestoload, &#39;all&#39;, list,
                                  loadmethodfolder)
    nblocksload = len(pressfiles)

    # Update the metadata
    self._pressurearrays.loadedpressurerange = [setfilestoload[0],
                                                setfilestoload[0] + nblocksload - 1]

    print(&#39;Starting to load pressure data&#39;)

    # Building path to first file for reading basic info
    filepath = ph.join(self._pressuresfullpath, pressfiles[0])

    with open(filepath, &#39;r&#39;) as f:
        readlines = f.readlines()
        ndatapoints = len(readlines[datarowidxstart:])

    # noinspection PyProtectedMember
    precision = self._pressurearrays._precision_calc
    nsets = len(pressfiles)

    calibrations = np.zeros((4, 2), dtype=precision)
    self._pressurearrays.time = np.zeros((ndatapoints, nsets), dtype=precision)
    self._pressurearrays.valve = np.zeros((ndatapoints, nsets), dtype=precision)
    self._pressurearrays.temperature = np.zeros(nsets, dtype=precision)
    self._pressurearrays.pressure_atm = np.zeros(nsets, dtype=precision)
    for i in range(1, npresslines+1):
        exec(&#39;self._pressurearrays.pressure&#39; + str(i) +
             &#39;.voltage= np.zeros((ndatapoints, nsets), dtype=precision)&#39;)
        exec(&#39;self._pressurearrays.pressure&#39; + str(i) +
             &#39;.calibration = np.zeros((2, nsets), dtype=precision)&#39;)

    for i, file in enumerate(pressfiles):
        filepath = ph.join(self._pressuresfullpath, file)
        with open(filepath, &#39;r&#39;) as f:
            readlines = f.readlines()

            # reads the pressure and temperature in
            readnums = findall(r&#39;[+\-]?(?:0|[1-9]\d*)(?:\.\d*)?(?:[eE][+\-]?\d+)&#39;,
                               readlines[roominfoidx].replace(&#39;,&#39;, &#39;.&#39;))
            self._pressurearrays.pressure_atm[i] = readnums[0]
            self._pressurearrays.temperature[i] = readnums[1]

            # Get the calibration data
            for j, line in enumerate(readlines[caliblineidx]):
                listofsplits = split(r&#39;\t+&#39;, line.replace(&#39;,&#39;, &#39;.&#39;).rstrip(&#39;\n&#39;))
                calibrations[:, j] = np.array(listofsplits)

            for j in range(1, npresslines+1):
                exec(&#39;self._pressurearrays.pressure&#39; + str(j) +
                     &#39;.calibration[:, i] = calibrations[&#39; + str(j-1) + &#39;, :]&#39;)

            # Subtract data series from file
            flatlines = sub(&#39;,&#39;, &#39;.&#39;, &#34;&#34;.join(readlines[datarowidxstart:]))
            data = np.array(findall(r&#39;[+\-]?(?:0|[1-9]\d*)(?:\.\d*)?(?:[eE][+\-]?\d+)&#39;,
                                    flatlines))
            data = data.reshape(-1, ndatalines)

            # Store data
            self._pressurearrays.time[:, i] = data[:, 0]
            self._pressurearrays.valve[:, i] = data[:, npresslines+1]
            for j in range(1, npresslines+1):
                exec(&#39;self._pressurearrays.pressure&#39; + str(j) +
                     &#39;.voltage[:, i] = data[: ,&#39; + str(j) + &#39;]&#39;)

    print(&#39;Done loading pressure data\n\n&#39;)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="PImGED treat" href="https://youtu
.be/mx86-rTclzA?si=RWJEgJIT8MdOsVn7">
<center><img src="https://i.ibb.co/Tbp2rPk/logo.png" alt=""></center>
</a>
</header>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pimged.datahandling" href="index.html">pimged.datahandling</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pimged.datahandling.dataloading.Dataload" href="#pimged.datahandling.dataloading.Dataload">Dataload</a></code></h4>
<ul class="">
<li><code><a title="pimged.datahandling.dataloading.Dataload.loadimages" href="#pimged.datahandling.dataloading.Dataload.loadimages">loadimages</a></code></li>
<li><code><a title="pimged.datahandling.dataloading.Dataload.loadpressures" href="#pimged.datahandling.dataloading.Dataload.loadpressures">loadpressures</a></code></li>
<li><code><a title="pimged.datahandling.dataloading.Dataload.loadpressuresOLD" href="#pimged.datahandling.dataloading.Dataload.loadpressuresOLD">loadpressuresOLD</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>